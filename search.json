[{"title":"零基础入门深度学习(1) - 感知器","url":"%2F2019%2F05%2F01%2Fdeeplearning-quickstart-1%2F","content":"\n![](http://upload-images.jianshu.io/upload_images/2256672-06627c71f0d8c0dc.jpg)\n\n> 无论即将到来的是大数据时代还是人工智能时代，亦或是传统行业使用人工智能在云上处理大数据的时代，作为一个有理想有追求的程序员，不懂深度学习（Deep Learning）这个超热的技术，会不会感觉马上就out了？现在救命稻草来了，《零基础入门深度学习》系列文章旨在讲帮助爱编程的你从零基础达到入门级水平。零基础意味着你不需要太多的数学知识，只要会写程序就行了，没错，这是专门为程序员写的文章。虽然文中会有很多公式你也许看不懂，但同时也会有更多的代码，程序员的你一定能看懂的（我周围是一群狂热的Clean Code程序员，所以我写的代码也不会很差）。\n\n## 文章列表\n\n* 零基础入门深度学习(1) - 感知器 \n* 零基础入门深度学习(2) - 线性单元和梯度下降 \n* 零基础入门深度学习(3) - 神经网络和反向传播算法 \n* 零基础入门深度学习(4) - 卷积神经网络 \n* 零基础入门深度学习(5) - 循环神经网络 \n* 零基础入门深度学习(6) - 长短时记忆网络(LSTM) \n* 零基础入门深度学习(7) - 递归神经网络\n\n## 深度学习是啥\n\n在人工智能领域，有一个方法叫机器学习。在机器学习这个方法里，有一类算法叫神经网络。神经网络如下图所示：\n\n![](http://upload-images.jianshu.io/upload_images/2256672-c6f640c11a06ac2e.png)\n\n上图中每个圆圈都是一个神经元，每条线表示神经元之间的连接。我们可以看到，上面的神经元被分成了多层，层与层之间的神经元有连接，而层内之间的神经元没有连接。最左边的层叫做 **输入层** ，这层负责接收输入数据；最右边的层叫 **输出层** ，我们可以从这层获取神经网络输出数据。输入层和输出层之间的层叫做 **隐藏层** 。\n\n隐藏层比较多（大于2）的神经网络叫做深度神经网络。而深度学习，就是使用深层架构（比如，深度神经网络）的机器学习方法。\n\n那么深层网络和浅层网络相比有什么优势呢？简单来说深层网络能够表达力更强。事实上，一个仅有一个隐藏层的神经网络就能拟合任何一个函数，但是它需要很多很多的神经元。而深层网络用少得多的神经元就能拟合同样的函数。也就是为了拟合一个函数，要么使用一个浅而宽的网络，要么使用一个深而窄的网络。而后者往往更节约资源。\n\n深层网络也有劣势，就是它不太容易训练。简单的说，你需要大量的数据，很多的技巧才能训练好一个深层网络。这是个手艺活。\n\n## 感知器\n\n看到这里，如果你还是一头雾水，那也是很正常的。为了理解神经网络，我们应该先理解神经网络的组成单元—— **神经元** 。神经元也叫做 **感知器** 。感知器算法在上个世纪50-70年代很流行，也成功解决了很多问题。并且，感知器算法也是非常简单的。\n\n### 感知器的定义\n\n下图是一个感知器：\n\n![](http://upload-images.jianshu.io/upload_images/2256672-801d65e79bfc3162.png)\n\n可以看到，一个感知器有如下组成部分：\n\n$$\nf(z)=\\begin{cases}\n1 \\quad x\\gt 0 \\\\\n\\\\\n0 \\quad othercase \\\\\n\\end{cases}\n\\tag{1}\n$$\n","tags":["深度学习入门"],"categories":["转载"]},{"title":"解决 \"Failed to Initialize NVML: Driver/library Version Mismatch\"","url":"%2F2019%2F04%2F24%2Fresolve-NVML-driver-version-mismatch%2F","content":"\n服务器更新 `nvidia driver` 后遇到以下问题:\n\n`Failed to initialize NVML: Driver/library version mismatch`\n\n## 一句话解决方案:\n\n```bash\n    # su 权限\n    lsmod | grep -i ^nvidia | awk '{print $1}' | rmmod && nvidia-smi\n```\n\n或者\n\n```bash\n    # 雾\n    sudo reboot\n```\n\n## 原因分析:\n\n驱动更新后 linux 内核对应驱动的 kernel module 并没有重置, 外部相关进程引用了旧版本驱动相关的 mod, 需要手动卸载, 重新执行 `nvidia-smi`\n会自动加载新版本 mod 到内核\n\n## 注意\n\n卸载过程可能会因为相关进程引用或者内核 mod 引用顺序导致卸载失败, 这时需要按照提示顺序卸载.\n\n<!-- more -->\n\n比如:\n\n```bash\n    rmmod nvidia\n    > rmmod: ERROR: Module nvidia is in use by: nvidia_modeset nvidia_uvm\n```\n\n这时就需要先卸载`nvidia_modeset` 和 `nvidia_uvm`\n\n一些相关的 `kernel mod` 命令\n\n* 查看进程引用 `mod`\n\n```bash\n    lsof -n -w /dev/nvidia\n```\n\n* kernel mod 卸载\n\n```bash\n    rmmod <module_name> | modprobe -r <module_name>\n```\n\n* kernel mod 加载\n\n```bash\n    modprobe\n```\n \n\n## 参考资料\n\n- [stackoverflow](https://stackoverflow.com/questions/43022843/nvidia-nvml-driver-library-version-mismatch)\n- [Comzyh的博客](https://comzyh.com/blog/archives/967/)\n- [archlinux](https://wiki.archlinux.org/index.php/Kernel_module)\n","tags":["nvidia"]},{"title":"支持 GPU 调度的 Kubernetes 部署方案(CentOS)","url":"%2F2019%2F04%2F16%2Finstall-k8s-cluster-with-gpu-support%2F","content":"## docker installation\n\n- optional: clean old version if needed\n```\nsudo yum remove docker \\\n                  docker-client \\\n                  docker-client-latest \\\n                  docker-common \\\n                  docker-latest \\\n                  docker-latest-logrotate \\\n                  docker-logrotate \\\n                  docker-engine \\\n                  docker-ce \\\n                  docker-ce-cli \\\n                  containerd.io\n```\n\n- install yum utils\n```\nsudo yum install -y yum-utils device-mapper-persistent-data lvm2\n```\n\n- add docker-ce repo\n```\nsudo yum-config-manager \\\n    --add-repo \\\n    https://download.docker.com/linux/centos/docker-ce.repo\n```\n\n<!-- more -->\n\n- install docker-ce\n```\nsudo yum install docker-ce docker-ce-cli containerd.io\n```\n\n- optional: setup docker `data-root`\n\n`dockerd` store `images/caches/volumes ...` data in `/var/lib/docker` by default, and the `kuberntes` will GC docker\nimage NOT CURRENT IN USING, change the `data-root` to a large disk portion.\n\n```\nsudo vi /usr/lib/systemd/system/docker.service\n\n> append --data-root <a large disk portion> behind dockerd Exec\n```\n\n## nvidia-docker | nvidia-container-runtime installation\n\n- add nvidia-docker repo\n```\ndistribution=$(. /etc/os-release;echo $ID$VERSION_ID)\ncurl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.repo | \\\n  sudo tee /etc/yum.repos.d/nvidia-docker.repo\n```\n\n- install nvidia-docker\n```\nsudo yum install nvidia-docker2\nsudo pkill -SIGHUP dockerd\n```\n\n- modify `/etc/docker/daemon.json` to enable `nvidia` as default docker runtime\n\n- optional: setup your own `shadowsocks server & client & privoxy`\n\n- modify `/usr/lib/systemd/system/docker.server` to enable docker image pull access to `gcr.io`\n\n```\nEnvironment=\"HTTP_PROXY=x.x.x.x:xx;HTTPS_PROXY=x.x.x.x:xx;NO_PROXY=x.x.x.x:xx\"\n```\n\n## kubernetes stack installation (local kubelet)\n\n- optional: remove outdated kubeadm, kubelet, kubectl\n\n```\nsudo yum remove -y kubeadm kubelet kubectl\n```\n\n- `kubelet`, `kubectl`, `kubeadm` install\n    >follow [here](https://kubernetes.io/docs/setup/independent/install-kubeadm/)\n\n- using `kubeadm` to install `HA` cluster\n    >follow [here](https://kubernetes.io/docs/setup/independent/setup-ha-etcd-with-kubeadm/)\n\n## kubernetes stack installation (rke -> stack in docker)\n\n- install [rke](https://github.com/rancher/rke)\n\n- rke up\n\n```yaml\n\nnodes:\n    - address: 192.168.1.14\n      user: jinyi\n      role:\n        - controlplane\n        - etcd\n        - worker\n    - address: 192.168.1.15\n      user: jinyi\n      role:\n        - controlplane\n        - etcd\n        - worker\n    - address: 192.168.1.16\n      user: jinyi\n      role:\n        - controlplane\n        - etcd\n        - worker\n\n```\n\n- more config [here](https://rancher.com/docs/rke/latest/en/)\n\n## apply services & conf to cluster\n\n### kubernetes-dashboard\n\n- apply stable `kubernetes-dashboard`\n\n```bash\n    kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v1.10.1/src/deploy/recommended/kubernetes-dashboard.yaml\n```\n\n- create `admin role binding` (local only for security)\n\n```bash\necho `\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: admin-user\n  namespace: kube-system\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: admin-user\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: cluster-admin\nsubjects:\n- kind: ServiceAccount\n  name: admin-user\n  namespace: kube-system\n` | kubectl apply -f -\n```\n\n- get `dashboard login token` & login to dashboard\n\n```bash\n    kubectl -n kube-system describe secrets admin-user | grep token:\n    \n    # copy the output token to clipboard\n    \n    # start local proxy\n    kubectl proxy\n    \n    # open in bro\n```\n\n- open in browser [kubernetes-dashboard](http://localhost:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/)\n\n- enter `token` you copy before & login\n","tags":["linux"]},{"title":"Css中清除浮动的几种方式","url":"%2F2016%2F10%2F26%2Fclear-float-of-ul%2F","content":"\n前端使用 `ul > li` + `float` 方式生成一个 `navbar` 是一种常见的页面展示手段, 但是浮动之后会导致`ul`高度无法正常撑起, 所以需要清除浮动以正常撑起父元素高度. 这里介绍几种常见的浮动清除的方式.\n\n```html\n    <ul>\n        <li></li>\n        <li></li>\n        <li></li>\n        <li></li>\n    </ul>\n```\n\n```css\n    ul {\n        margin: 0 0;\n        padding: 0 0;\n        list-style-type: none;\n    }\n\n    li {\n        float: right;\n        width: 80px;\n        height: 40px;\n        margin-right: 5%;\n        margin-bottom: 10px;\n        line-height: 40px;\n        text-align: center;\n    }\n```\n\n<!-- more -->\n\n### 给ul添加高度\n\n    这个是最直接的方法, 给`ul`元素添加一个高度\n\n    ```css\n        ul {\n            height: 40px;\n        }\n    ```\n\n### 给最后一个li后添加一个 **空的** `div`, 给`div`添加`clear: both`样式\n\n    ```html\n        <li>\n        </li>\n        <div style=\"clear:both;\"></div>\n    ```\n\n### 给ul添加`overflow: hidden; zoom: 1`样式\n\n    ```css\n        ul {\n            overflow: hidden;\n            zoom: 1;\n        }\n    ```\n\n### 使用 ul **伪类** 进行浮动清除, 对`ul`添加`class=\"clearfix\"`\n\n    ```css\n        .clearfix {\n            *zoom: 1;\n        }\n        .clearfix:before, .clearfix:after {\n            display: table;\n            line-height: 0;\n            content: \"\";\n        }\n        .clearfix:after {\n            clear: both;\n        }\n    ```\n\n#### 参考链接\n* [推酷](http://www.tuicool.com/articles/3iuaMzn)\n","tags":["浮动"]},{"title":"Nodejs版本更新记录","url":"%2F2016%2F10%2F19%2Fnodejs-versions-update-mark-md%2F","content":"\nv6今天LTS, 官方pending了半个多月今天终于up了. 记录一下node主要版本更新内容, 方便选择. 关于官方进度及相关版本计划可以参考[这里](https://github.com/nodejs/lts), 看起来现在用`V4` 和 `V6` 是明智的, `V5`还是放弃吧.\n\n## v4.x\n\n```\n    v4 更新\n    1. 模板字符串\n    2. 类语法糖\n    3. 箭头函数\n    4. 对象字面量\n    5. Promise\n    6. 新的字符串方法\n    7. let 和 const\n```\n\n## v6.x\n\n```\n    nodejs更新主要新特性\n    1. 默认函数参数\n    2. 展开操作符\n    3. 解构赋值\n    4. new.target\n    5. Proxy, 原生对象\n    6. Reflect, 原生对象\n    7. Symbol, 原生对象\n```\n\n\n### 参考资料\n* [v4](http://wwsun.github.io/posts/upgrade-to-node-v4.html)\n* [v6](http://www.tuicool.com/articles/bqmiU3q)\n"},{"title":"Linux服务器安全设置","url":"%2F2016%2F03%2F18%2Flinux-server-setting%2F","content":"\n简明的linux服务器安全设置指南, 包括: 公钥登录, 禁止密码登录, 禁用 root 账户等.\n\n公司的阿里云主机常年被 ssh 外加 http 各种扫, 除了一方面写出更加安全, 健壮的代码之外, 另一方面服务器的安全设置也不容忽视.\n下面是我自己常用的服务器端相关配置. 阿里云主机, centOS 6.x.\n\n## 账户设置\n\n添加公共账户, 避免直接使用 root 账户.\n阿里云的主机默认只提供了一个 root 账户, 我们需要添加一个工作账户, 并赋予 root 权限, 避免直接使用 root.\n\n```sh\n    useradd devops         //添加 devops 账户\n    passwd devops          //修改 devops 账户密码\n    useradd -G root devops //添加 devops 到 root 用户组\n```\n\n这样我们就拥有了一个 root 权限的账户, 接下来就是禁止 root 账户的 shell 登录和使用.\n\n<!-- more -->\n由于我们以后不会再使用密码登录, 并且要禁止 root 的 shell 登录. 所以, 在禁用之前, 需要先配置好公钥文件, 防止无法正常登录服务器.\n\n1. 生成密钥(ssh-keygen)\n2. 复制公钥到服务器(ssh-copy-id)\n3. 修改 ssh server 配置文件, 允许公钥认证, sudo vi /etc/ssh/sshd_config\n```\n    RSAAuthentication yes       //开启RSA 及公钥认证\n    PubkeyAuthentication yes\n```\n\n4. 修改服务器端文件夹的拥有者及权限, 权限设置是必须的, 否则不能正常识别公钥\n```sh\n    chown -R devops:devops .ssh         //修改.ssh 文件夹的拥有者\n    chmod 700 .ssh                      //修改文件夹权限为700,必须\n    chmod 600 .ssh/authorized_keys      //修改文件权限为600,必须\n    sudo services sshd restart          //重启 ssh 服务\n```\n\n接下来进行 ssh 登录测试, 如果正常登录且未提示输入密码, 证明我们的公钥配置已经生效, 这个时候就可以大胆的关闭 root 账户登录和账户登录的密码验证了.\nsudo vi /etc/ssh/sshd_config\n\n```sh\n    PermitRootLogin no          //禁止 root 用户登录\n    PasswordAuthentication no   //禁用密码验证\n```\n\n## 端口设置及 iptables\n\n除了做到以上的还不能确保足够的安全, 我们需要对服务器的端口进行限定开放.\n\n我司服务器目前对外开放端口只有80, 443, 22三个端口, 即除了 ssh, http, https 之外, 不对外部开放任何端口.有需要可以修改 ssh 默认端口号, sudo vi /etc/ssh/sshd_config\n```\n    port xx\n```\n\n这个配置可以在阿里云的控制面板内进行设置, 当然本地进行设置也是一样的道理.\n\n由于阿里云的机房内不是一台机器, 也就是说尽管我们的主机没有暴露在外网环境下, 但是阿里云的内网内部还是可以扫描到我们的服务器的.所以,\n我们还需要使用 iptables 对内网 ip 进行限制.\n\n我司在阿里有两台服务器, 分布在同一个内网环境, 所以除了两者之间互访之外, 屏蔽所有其他的内网互访. 这个在阿里云主机的控制面板也是可以设置的, iptables 同理.\n\n## 其他\n\n防火墙保持常开, 定时备份, 磁盘加密, 及时查 ssh 和 http 的相关 log, 发现可疑情况及时处理.\n另, 对于 http 层可以在 nginx 接入层设置 ip 黑名单进行屏蔽.\n","tags":["linux"]},{"title":"Nginx配置访问限制","url":"%2F2016%2F03%2F17%2FNginx-secret-limit-setting%2F","content":"\n使用 ngxin 时添加IP访问控制是常见需求, 最近遇到该需求, 简单记录如下.\n\n## 模块依赖\n nginx 的 IP 访问控制依赖于内置的 `ngx_http_access_module`. 在默认情况下, 这个包在编译中是安装的, 除非编译过程中显示指定`--without ngx_http_access_module`.\n\n## 配置方法\n\n样例配置如下, example.conf\n```nginx\nlocation / {\n    deny  192.168.1.1;\n    allow 192.168.1.0/24;\n    allow 10.1.1.0/16;\n    allow 2001:0db8::/32;\n    deny  all;\n}\n\n```\n\n<!-- more -->\n\n写完之后 include 到配置文件即可\n`include /path/to/your_conf/*.conf;`\nPS: 记得加分号, `;`\n\nnginx 对于匹配顺序有如下规定: 任何一个 IP 地址, 访问了该 location 之后, 则`从上到下`对规则进行匹配, `漏斗`原则~ . ~ .\n举例如下:\n\n- `192.168.1.1`: 进入之后匹配到第一个`IP/IP 段`, 则执行对应的规则 `deny`, 返回.\n- `192.168.1.12`: 进入之后第一个未匹配, 跳过; 匹配到第二个, 执行对应规则 `allow`, 返回.\n- `172.168.1.101`: 进入之后前四个都未匹配到, 匹配最后一个 `all`, 执行 `deny`, 返回.\n\n## 配置语法\n\n```\n    Syntax: (allow|deny) address | CIDR | unix: | all\n    Default: —\n    Context: http, server, location, limit_except\n```\n\n语法设置可以为 `allow|deny` 两个关键字, 后面的对应属性可以为 IP 地址/地址段(可以使ipv4 或者 ipv6), CIRD(见[附1](#tip1)), `unix:`, `all`, 无默认值.\n配置模块可以出现在 nginx 的 `http{}`, `server{}`, `location{}`, `limit_except{}` 模块.\n如果属性值配置为`unix:`, 则会允许或拒绝所有 Unix 域socket.(该选项只在 nginx 1.5.1之后的版本生效)\n\n## 可用的第三方配置模块\n nginx 只提供了简单的静态 IP 控制, 不过在服务端接入层用于做长效黑名单控制已经足够了, 如果针对访问控制进行动态规则调整, 我找到了`这货`\n [ngx_white_black_list](https://github.com/codehunte/ngx_white_black_list/blob/master/white_black_list.txt')\n\n\n简单说到这里, 其实还是挺简单的, 注意理一下匹配规则.\n\n* [附1](#tip1):\n\n`无类别域间路由`\n\n>无类别域间路由（Classless Inter-Domain Routing、CIDR）是一个用于给用户分配IP地址以及在互联网上有效地路由IP数据包的对IP地址进行归类的方法。\n在域名系统出现之后的第一个十年里，基于分类网络进行地址分配和路由IP数据包的设计就已明显显得可扩充性不足 （参见RFC 1517）。为了解决这个问题，互联网工程工作小组在1993年发布了一新系列的标准——RFC 1518和RFC 1519——以定义新的分配IP地址块和路由IPv4数据包的方法。\n一个IP地址包含两部分：标识网络的前缀和紧接着的在这个网络内的主机地址。在之前的分类网络中，IP地址的分配把IP地址的32位按每8位为一段分开。这使得前缀必须为8，16或者24位。因此，可分配的最小的地址块有256（24位前缀，8位主机地址，28=256）个地址，而这对大多数企业来说太少了。大一点的地址块包含65536（16位前缀，16位主机，216=65536）个地址，而这对大公司来说都太多了。这导致不能充分使用IP地址和在路由上的不便，因为大量的需要单独路由的小型网络（C类网络）因在地域上分得很开而很难进行聚合路由，于是给路由设备增加了很多负担。\n\n<\n\n>无类别域间路由是基于可变长子网掩码（VLSM）来进行任意长度的前缀的分配的。在RFC 950（1985）中有关于可变长子网掩码的说明。CIDR包括：\n指定任意长度的前缀的可变长子网掩码技术。遵从CIDR规则的地址有一个后缀说明前缀的位数，例如：192.168.0.0/16。这使得对日益缺乏的IPv4地址的使用更加有效。\n将多个连续的前缀聚合成超网，以及，在互联网中，只要有可能，就显示为一个聚合的网络，因此在总体上可以减少路由表的表项数目。聚合使得互联网的路由表不用分为多级，并通过VLSM逆转“划分子网”的过程。\n根据机构的实际需要和短期预期需要而不是分类网络中所限定的过大或过小的地址块来管理IP地址的分配的过程。\n因为在IPv6中也使用了IPv4的用后缀指示前缀长度的CIDR，所以IPv4中的分类在IPv6中已不再使用。\n\n<\n\n>摘自维基百科: [无类别域间路由]('https://zh.wikipedia.org/wiki/%E6%97%A0%E7%B1%BB%E5%88%AB%E5%9F%9F%E9%97%B4%E8%B7%AF%E7%94%B1')\n","tags":["安全"]},{"title":"2016读书单","url":"%2F2016%2F03%2F10%2F2016-reading-list%2F","content":"\n2016年新年读书计划, 准备深入学习JavaScript 的前端和后端开发, 大致了解一下 web 开发周围的相关知识.\n\n## 网络相关\n  http 协议的深入了解, nginx 开发相关, web 安全相关\n  ```\n    * 图解 http\n    * http 权威指南\n    * 跟我学 Nginx + Lua 开发\n    * Programming in Lua 3ed\n    * 白帽子讲 web 安全\n  ```\n\n## web 前端相关\n  html&css 深入理解, bootstrap 框架, JavaScript 深入学习\n  ```\n    * html5 与 css3 基础教程\n    * css 禅意花园\n    * css 权威指南\n    * 深入理解 bootstrap\n    * JavaScript 高级程序设计(第三版)\n    * JavaScript 启示录\n    * JavaScript 语言精粹\n  ```\n\n<!-- more -->\n\n## nodejs 相关进阶\n  nodejs 底层理解, nodejs 加载 C/C++ addon, 全栈\n  ```\n    * nodejs 权威指南\n    * web 全栈工程师的自我修养\n    * C Primer Plus(第五版)\n    * C++ Primer中文版\n  ```\n\n## 架构设计&软件工程相关\n  web 架构设计, 软件工程管理\n  ```\n    * 人月神话\n    * 程序之美系列(架构之美, 安全之美, 数据之美)\n    * 大型网站技术架构: 核心原理与案例分析\n  ```\n\n## 七周系列\n  七周相关经典\n  ```\n    * 七周七语言\n    * 七周七并发模型\n    * 七周七数据库\n    * 七周七 web 开发框架\n  ```\n","tags":["读书"]}]